<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Linguaggi formali</title>
    <link rel="stylesheet" type="text/css" href="../assets/reveal/reveal.css">
    <link rel="stylesheet" type="text/css" href="../assets/css/vs.css">
    <link rel="stylesheet" type="text/css" href="../assets/css/main.css">
  </head>
  <body>
    <div class="reveal">
      <div id="root" class="slides">
	<h1 class="no_toc" id="linguaggi-formali-e-traduttori">Linguaggi Formali e Traduttori</h1>

<h2 class="sezione" id="13-linguaggi-formali">1.3 Linguaggi formali</h2>

<ul class="smaller" id="markdown-toc">
  <li><a href="#alfabeti" id="markdown-toc-alfabeti">Alfabeti</a></li>
  <li><a href="#stringhe" id="markdown-toc-stringhe">Stringhe</a></li>
  <li><a href="#operazioni-e-nozioni-sulle-stringhe" id="markdown-toc-operazioni-e-nozioni-sulle-stringhe">Operazioni e nozioni sulle stringhe</a></li>
  <li><a href="#linguaggi" id="markdown-toc-linguaggi">Linguaggi</a></li>
  <li><a href="#esempi-2" id="markdown-toc-esempi-2">Esempi</a></li>
  <li><a href="#operazioni-su-linguaggi" id="markdown-toc-operazioni-su-linguaggi">Operazioni su linguaggi</a></li>
  <li><a href="#approcci-per-la-descrizione-di-linguaggi" id="markdown-toc-approcci-per-la-descrizione-di-linguaggi">Approcci per la descrizione di linguaggi</a></li>
  <li><a href="#il-problema-del-riconoscimento" id="markdown-toc-il-problema-del-riconoscimento">Il problema del riconoscimento</a></li>
  <li><a href="#esercizi" id="markdown-toc-esercizi">Esercizi</a></li>
  <li><a href="#soluzioni" id="markdown-toc-soluzioni">Soluzioni</a></li>
</ul>

<div class="license">

  <p>È proibito condividere e divulgare in qualsiasi forma i materiali
didattici caricati sulla piattaforma e le lezioni svolte in
videoconferenza: ogni azione che viola questa norma sarà denunciata
agli organi di Ateneo e perseguita a termini di legge.</p>

</div>

<h1 id="alfabeti">Alfabeti</h1>

<h2 id="definizione">Definizione</h2>

<p>Un <strong>alfabeto</strong> è un insieme <em>finito</em> e <em>non vuoto</em> di <strong>simboli</strong></p>

<h2 id="notazione">Notazione</h2>

<ul>
  <li>Usiamo $\Sigma$ per indicare un alfabeto generico</li>
  <li>Usiamo $a$, $b$, $c$, $\dots$ per indicare simboli generici di un
alfabeto (non necessariamente lettere dell’alfabeto latino!)</li>
</ul>

<h2 id="esempi">Esempi</h2>

<ol>
  <li>$\Sigma_1 = \set{ 0, 1 }$ alfabeto delle <em>cifre binarie</em></li>
  <li>$\Sigma_2 = \set{ 0, 1, \dots, 9 }$ alfabeto delle <em>cifre decimali</em></li>
  <li>$\Sigma_3 = \set{ \texttt{a}, \texttt{b}, \dots, \texttt{z}, \texttt{A},
\texttt{B}, \dots, \texttt{Z} }$ lettere dell’<em>alfabeto latino</em></li>
  <li>$\Sigma_2 \cup \set{ {.} }$ alfabeto dei simboli per
rappresentare “numeri con virgola”</li>
  <li>$\Sigma_2 \cup \Sigma_3 \cup \set{ \underline{~} }$ alfabeto dei
simboli degli identificatori in Java</li>
  <li>$\Sigma_4 = \set{ \blacktriangle, \blacksquare, \blacklozenge, \dots }$
 alfabeto di <em>figure geometriche</em></li>
</ol>

<h1 id="stringhe">Stringhe</h1>

<h2 id="definizione-1">Definizione</h2>

<p>Una <strong>stringa</strong> (o <strong>parola</strong> o <strong>frase</strong>) su un alfabeto $\Sigma$ è
una sequenza <em>finita</em> di simboli in $\Sigma$</p>

<h2 id="notazione-1">Notazione</h2>

<ul>
  <li>Usiamo $u$, $v$, $w$, $\dots$ per indicare stringhe generiche</li>
  <li>Usiamo $\varepsilon$ per indicare la <strong>stringa vuota</strong>, quella
composta da zero simboli</li>
</ul>

<h2 id="definizione-2">Definizione</h2>

<p>Diciamo che due stringhe sono <strong>uguali</strong> se e solo se sono composte
dagli stessi simboli nello stesso ordine (es. $\mathtt{caos} ≠
\mathtt{caso}$)</p>

<h1 id="operazioni-e-nozioni-sulle-stringhe">Operazioni e nozioni sulle stringhe</h1>

<p>La <strong>lunghezza</strong> di una stringa $u$ è il numero di simboli di cui è
costituita e si indica con $\len{u}$. Ad esempio, $\len{aab} = 3$ e
$\len\varepsilon = 0$</p>

<p>La <strong>concatenazione</strong> di $u$ e $v$, indicata con $uv$, è la stringa
ottenuta giustapponendo i simboli di $u$ seguiti dai simboli di
$v$. Esempio: la concatenazione di <code class="language-plaintext highlighter-rouge">po</code> e <code class="language-plaintext highlighter-rouge">sta</code> è <code class="language-plaintext highlighter-rouge">posta</code></p>

<p>La concatenazione è neutra rispetto alla stringa vuota (cioè
$u\varepsilon = \varepsilon u = u$), è <em>associativa</em> (cioè $u(vw) =
(uv)w$), ma <em>non commutativa</em> (in generale $uv \ne vu$).</p>

<p>Una stringa $u$ è un <strong>prefisso</strong> (rispettivamente, un <strong>suffisso</strong>)
di un’altra stringa $w$ se esiste $v$ tale che $w = uv$
(rispettivamente, $w = vu$). Esempio: <code class="language-plaintext highlighter-rouge">ta</code> è prefisso di <code class="language-plaintext highlighter-rouge">tacco</code></p>

<p>L’<strong>inversa</strong> di $w = a_1a_2\cdots a_n$ è la stringa $w^R =
a_n\cdots a_2a_1$. Esempio: $\mathtt{casa}^R = \mathtt{asac}$</p>

<p>Una stringa $w$ è <strong>palindroma</strong> se è uguale alla sua inversa ($w =
w^R$). Esempio: <code class="language-plaintext highlighter-rouge">radar</code></p>

<p>La <strong>potenza</strong> $n$-esima di $u$, indicata con $u^n$, è la stringa
ottenuta concatenando $u$ $n$ volte, ovvero $u^n =
\underbrace{uu⋯u}_{\text{$n$ volte}}$. Come casi particolari abbiamo
$u^0 = \varepsilon$ e $u^1 = u$</p>

<!-- # Ordine lessicografico -->

<!-- ## Definizione -->

<!-- Dato un alfabeto $\Sigma$ totalmente ordinato e date due stringhe -->
<!-- $u_1$ e $u_2$ su $\Sigma$, diciamo che $u_1$ è **lessicograficamente -->
<!-- minore o uguale** a $u_2$, notazione $u_1 \leq u_2$, se si verifica -->
<!-- una delle seguenti condizioni: -->

<!-- * $u_1$ è un prefisso di $u_2$, oppure -->
<!-- * $u_1 = vaw_1$ e $u_2 = vbw_2$ e $a < b$ -->

<!-- ## Note -->

<!-- * l'ordine lessicografico è riflessivo e transitivo (dimostrare per -->
<!--   esercizio) -->
<!-- * la stringa vuota $\varepsilon$ è l'elemento **minimo** di $\leq$ (perché?) -->

<!-- ## Esempi -->

<!-- * `po` $<$ `poco` (in quanto `po` è prefisso di `poco`) -->
<!-- * `cane` $<$ `canto` (in quanto `e` $<$ `t`) -->
<!-- * `canto` $<$ `casa` (in quanto `n` $<$ `s`, notare che `canto` è più lunga ma minore) -->

<h1 id="linguaggi">Linguaggi</h1>

<h2 id="definizione-3">Definizione</h2>

<p>Un <strong>linguaggio</strong> $L$ su un alfabeto $\Sigma$ è un qualunque insieme
di stringhe su $\Sigma$</p>

<h2 id="notazione-2">Notazione</h2>

<ul>
  <li>Usiamo $\Sigma^\ast$ per indicare l’insieme di tutte le stringhe
su $\Sigma$, inclusa quella vuota</li>
  <li>Usiamo $\Sigma^+$ per indicare l’insieme di tutte le stringhe <em>non
vuote</em> su $\Sigma$</li>
</ul>

<h2 id="esempi-1">Esempi</h2>

<ul>
  <li>Se $Σ = \set{ 0, 1 }$ abbiamo $Σ^\ast = \set{ \es, 0, 1, 00, 01, 10,
11, 000, 001, 010, 100, 011, \dots }$</li>
  <li>Se $\Sigma = \set{ a }$ abbiamo $\Sigma^+ = \set{ a, aa, aaa,
aaaa, \dots }$</li>
</ul>

<h1 id="esempi-2">Esempi</h1>

<ol>
  <li>$\set{ a^{2n+1} \mid n \in \bN }$ <span class="fragment">è il
linguaggio delle stringhe di $a$ di lunghezza dispari</span></li>
  <li>$\set{ a^mb^n \mid m,n\in\bN }$ <span class="fragment">è il
linguaggio delle parole composte da un numero arbitrario di $a$
seguite da un numero arbitrario di $b$</span></li>
  <li>$\set{ a^nb^n \mid n \in \bN }$ <span class="fragment">è il
linguaggio delle parole composte da un numero arbitrario di $a$
seguite dallo <em>stesso numero</em> di $b$</span></li>
  <li>$\set{ w \in \set{a,b}^* \mid w = w^R }$ <span class="fragment">è il linguaggio delle stringhe palindrome su
$\set{a,b}$</span></li>
</ol>

<h2 id="linguaggi-particolari">Linguaggi particolari</h2>

<ol>
  <li>$L = \emptyset$ è il <strong>linguaggio vuoto</strong>, da non confondere con il seguente</li>
  <li>$L = \set\varepsilon$ è il linguaggio composto dalla sola stringa
vuota</li>
  <li>$L = \Sigma$ è il linguaggio costituito dai simboli dell’alfabeto</li>
  <li>$L = \Sigma^n = \set{ w \mid w\in\Sigma^* \wedge |w| = n }$ è il
linguaggio delle stringhe lunghe $n$</li>
</ol>

<h1 id="operazioni-su-linguaggi">Operazioni su linguaggi</h1>

<p>Sono definite le seguenti <strong>operazioni</strong> su linguaggi:</p>

<table>
  <thead>
    <tr>
      <th>Operazione</th>
      <th>Definizione</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Unione</td>
      <td>$L_1 \cup L_2$</td>
    </tr>
    <tr>
      <td>Intersezione</td>
      <td>$L_1 \cap L_2$</td>
    </tr>
    <tr>
      <td>Complemento (rispetto a $\Sigma$)</td>
      <td>$\overline{L} = \Sigma^\ast - L$</td>
    </tr>
    <tr>
      <td>Concatenazione</td>
      <td>$L_1L_2 = \set{ uv \mid u\in L_1, v\in L_2 }$</td>
    </tr>
    <tr>
      <td>Potenza</td>
      <td>$L^0 = \set\varepsilon \qquad L^{n+1} = LL^n$</td>
    </tr>
    <tr>
      <td>Chiusura di Kleene</td>
      <td>$L^\ast = L^0 \cup L^1 \cup L^2 \cup \cdots = \bigcup_{i\in\bN} L^i$</td>
    </tr>
    <tr>
      <td>Chiusura transitiva</td>
      <td>$L^+ = L^1 \cup L^2 \cup \cdots = \bigcup_{i\in\bN - \set0} L^i$</td>
    </tr>
  </tbody>
</table>

<h2 id="note">Note</h2>

<ul>
  <li>La concatenazione è <em>associativa</em> ma <em>non commutativa</em> in generale.</li>
  <li>La chiusura di Kleene di $L$ produce un linguaggio <em>infinito</em>, a
meno che $L \subseteq \set\varepsilon$. Ad esempio,
$\set{a}^\ast = \set{ a^n \mid n \in \bN }$.</li>
</ul>

<h1 id="approcci-per-la-descrizione-di-linguaggi">Approcci per la descrizione di linguaggi</h1>

<h2 id="problema">Problema</h2>

<ul>
  <li>I linguaggi interessanti contengono solitamente un numero
<strong>infinito</strong> di stringhe</li>
  <li>Non è pensabile descriverli semplicemente elencandone tutte le
stringhe (come accade, ad esempio, con le parole della lingua
italiana)</li>
  <li>Occorre un approccio <strong>finito</strong> per descrivere un linguaggio
<strong>infinito</strong></li>
</ul>

<h2 id="approccio-generativo">Approccio generativo</h2>

<ul>
  <li>linguaggio = stringhe <strong>generate</strong> da una <strong>grammatica</strong> o
<strong>espressione regolare</strong></li>
</ul>

<h2 id="approccio-riconoscitivo">Approccio riconoscitivo</h2>

<ul>
  <li>linguaggio = stringhe <strong>riconosciute</strong> da un <strong>automa</strong></li>
</ul>

<h2 id="perché-due-approcci">Perché due approcci?</h2>

<ul>
  <li>grammatiche ed espressioni regolari sono facili da leggere e
scrivere per gli umani</li>
  <li>gli automi sono efficienti da “eseguire” per i calcolatori</li>
  <li>i due approcci possono essere messi in relazione! (lo vedremo in
questo corso)</li>
</ul>

<h1 id="il-problema-del-riconoscimento">Il problema del riconoscimento</h1>

<div class="block ">
  <p>Data una descrizione (finita) di un linguaggio $L$ (potenzialmente
infinito) e una stringa $w$, determinare se $w ∈ L$</p>
</div>

<ul>
  <li>Il linguaggio $L$ è solitamente descritto usando espressioni
regolari o grammatiche libere</li>
  <li>L’automa o il parser che riconosce $L$ è <strong>generato</strong>
automaticamente</li>
</ul>

<h1 id="esercizi">Esercizi</h1>

<h2 id="esercizio-1">Esercizio 1</h2>

<p>Dimostrare con dei controesempi che non sono valide le seguenti
relazioni. Per ciascuna di esse, trovare la forma corretta o delle
condizioni sufficienti a farla valere:</p>

<ol>
  <li>$L\emptyset = \emptyset L = L$</li>
  <li>$L\set\varepsilon = \set\varepsilon L = \set\varepsilon$</li>
  <li>$L_1L_2 = L_2L_1$</li>
  <li>$L^+ = L^\ast - \set\varepsilon$</li>
</ol>

<h2 id="esercizio-2">Esercizio 2</h2>

<p>Elencare dieci stringhe dei seguenti linguaggi definiti
sull’alfabeto $\Sigma = \set{a,b,c}$:</p>

<ol>
  <li>$(\Sigma^2 \cup \Sigma^3)\set{a,b}$</li>
  <li>$\Sigma^+ - \set{b,c}^\ast$</li>
  <li>$\set{ w \in \Sigma^\ast \mid \text{$w$ contiene un egual numero di $a$, $b$ e $c$} }$</li>
  <li>$\set{ w \in \Sigma^\ast \mid \text{$w$ è palindroma, ovvero $w = w^R$} }$</li>
</ol>

<h1 id="soluzioni">Soluzioni</h1>

<h2 id="esercizio-1-1">Esercizio 1</h2>

<ol>
  <li>$L\emptyset = \emptyset L = \emptyset$</li>
  <li>$L\set\varepsilon = \set\varepsilon L = L$</li>
  <li>$L_1L_2 = L_2L_1$ se $L_1 = \emptyset$ o $L_1 = \set\varepsilon$
o $L_1 = L_2$ o $L_1 = L_2^\ast$ ecc.</li>
  <li>$L^+ = L^\ast - \set\varepsilon$ se $\varepsilon\not\in L$</li>
</ol>

<h2 id="esercizio-2-1">Esercizio 2</h2>

<ol>
  <li>$aaa$, $aba$, $aca$, $caa$, $cab$, $baa$, $bba$, $bca$, $bcb$, $aaab$, …</li>
  <li>tutte le stringhe che contengono almeno una $a$, ad es. $a$,
$ab$, $ba$, $ac$, $ca$, $abb$, $bac$, …</li>
  <li>$\es$, $abc$, $acb$, $bac$, $bca$, $cab$, $cba$, $aabbcc$,
$aabcbc$, $aaccbb$, …</li>
  <li>$\es$, $a$, $b$, $c$, $aa$, $bb$, $cc$, $aaa$, $aba$, $aca$, …</li>
</ol>

      </div>
    </div>
    <script type="text/javascript" src="../js/slider.js"></script>
    <script type="text/javascript" src="../assets/reveal/reveal.js"></script>
    <script>
      initialize_slider();
      Reveal.initialize({
	  controls:    false,  // No control arrows
	  slideNumber: 'c/t',  // Print slide number
	  center:      false,  // Do not align slide vertically
	  progress:    false,  // Do not display progress bar
	  hash:        true,   // Store slide number in URL
	  touch:       true,   // Enables touch navigation
	  transition:  'none', // Transition mode
	  transitionSpeed: 'fast',
	  pdfSeparateFragments: true,
	  pdfMaxPagesPerSlide: 1,
	  pdfPageHeightOffset: -1,
	  width: 846,
	  height: 600,
	  margin: 0.05,
      });
    </script>
    <script type="text/javascript" src="../js/mathjax.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </body>
</html>
